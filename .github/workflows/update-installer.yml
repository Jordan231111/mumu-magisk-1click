name: Update MuMu Installer

on:
  workflow_dispatch: # Allows manual triggering
  schedule:
    - cron: '0 0 1 * *' # Runs at 00:00 on the 1st day of every month

permissions:
  contents: write # Needed to commit and push changes

jobs:
  update:
    runs-on: windows-latest # Changed from ubuntu-latest
    defaults:
      run:
        shell: pwsh # Use PowerShell
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download latest installer and update README
        id: update_script
        run: |
          $downloadUrl = "https://adl.netease.com/d/g/a11/c/cn_top?dfuid=elk_nUX7eop&nonce=bdc9iC"
          $installerPattern = "MuMuInstaller_*.exe"
          $readmeFile = "README.md"
          $changesMade = "false" # Default to no changes

          Write-Host "Looking for existing installer..."
          # Find the current installer filename in the repo
          $oldInstallerItem = Get-ChildItem -Path . -Filter $installerPattern | Sort-Object LastWriteTime -Descending | Select-Object -First 1
          $oldInstaller = $oldInstallerItem.Name
          if (-not $oldInstaller) {
            Write-Warning "Could not find existing installer matching pattern '$installerPattern'."
            # Optionally, extract from README as fallback (more complex in PS)
            # $readmeContent = Get-Content $readmeFile -Raw
            # $match = [regex]::Match($readmeContent, 'MuMuInstaller_([^\"]*)\.exe')
            # if ($match.Success) { $oldInstaller = $match.Value }
          }
          Write-Host "Found existing installer: $oldInstaller"

          Write-Host "Attempting to determine download filename from $downloadUrl"
          $downloadPath = "." # Download to current directory
          $newInstaller = $null
          $response = $null

          try {
            # Step 1: Make an initial request to follow redirects and get headers/final URL
            $request = [System.Net.WebRequest]::Create($downloadUrl)
            $request.AllowAutoRedirect = $true
            # $request.Method = 'HEAD' # Use HEAD request to avoid downloading body initially <-- REVERTING THIS
            # Default method is GET, which is needed for this server to provide filename

            $response = $request.GetResponse()

            # Step 2: Try getting filename from Content-Disposition header
            $contentDisposition = $response.Headers['Content-Disposition']
            if ($contentDisposition) {
                Write-Host "Found Content-Disposition header: $contentDisposition"
                $fileNameMatch = [regex]::Match($contentDisposition, 'filename="?([^"]+)"?')
                if ($fileNameMatch.Success) {
                    $newInstaller = $fileNameMatch.Groups[1].Value.Trim()
                    Write-Host "Extracted filename from Content-Disposition: $newInstaller"
                }
            }

            # Step 3: If header failed, try getting filename from the final URL
            if (-not $newInstaller) {
                $finalUri = $response.ResponseUri.AbsoluteUri
                Write-Host "Content-Disposition did not yield filename. Trying final URL: $finalUri"
                if ($finalUri) {
                    $newInstaller = [System.IO.Path]::GetFileName($finalUri)
                    if ($newInstaller -match '^\?' ) { # Handle cases where filename might be in query string (less common for downloads)
                         Write-Warning "Filename from URL seems to be a query string. Clearing."
                         $newInstaller = $null
                    } else {
                        Write-Host "Extracted filename from final URL: $newInstaller"
                    }
                }
            }

            # Step 4: Validate filename and proceed with actual download
            if (-not $newInstaller -or $newInstaller -notlike $installerPattern) {
                Write-Error "Failed to determine a valid installer filename (pattern: $installerPattern). Found: '$newInstaller'"
                Write-Host "changes_made=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
                exit 0
            }

            $fullPath = Join-Path $downloadPath $newInstaller
            Write-Host "Determined filename: $newInstaller. Proceeding with download to $fullPath"

            # Perform the actual download using Invoke-WebRequest
            Invoke-WebRequest -Uri $downloadUrl -OutFile $fullPath -UseBasicParsing -ErrorAction Stop
            Write-Host "Download successful."

          } catch {
            Write-Error "Operation failed: $($_.Exception.Message)"
            Write-Host "changes_made=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
            exit 0 # Exit cleanly, no changes
          } finally {
              # Ensure the response stream is closed
              if ($response -ne $null) {
                  $response.Close()
                  $response = $null
              }
          }

          # Check if file exists after download attempt
          if (-not (Test-Path -Path $fullPath)) {
            Write-Error "Installer file $newInstaller not found after download attempt."
            Write-Host "changes_made=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
            exit 0 # Exit cleanly, no changes
          }

          Write-Host "Downloaded/Found new installer: $newInstaller"

          # Compare old and new filenames
          if (($newInstaller -ne $oldInstaller) -and $oldInstaller) {
            Write-Host "New version detected ($newInstaller vs $oldInstaller). Updating..."
            $changesMade = "true"

            Write-Host "Removing old installer: $oldInstaller"
            Remove-Item -Path $oldInstaller -Force -ErrorAction SilentlyContinue

            Write-Host "Updating README.md..."
            $readmeContent = Get-Content $readmeFile -Raw
            # Escape regex special characters in filenames if necessary (though unlikely for this pattern)
            $oldInstallerEscaped = [regex]::Escape($oldInstaller)
            $newInstallerEscaped = [regex]::Escape($newInstaller)
            # Use -replace operator for regex replacement
            $updatedReadmeContent = $readmeContent -replace "(curl -L `"https://raw.githubusercontent.com/Jordan231111/mumu-magisk-1click/main/)$oldInstallerEscaped(`" -o mumu_installer.exe\)", "`$1$newInstaller`$2"

            if ($readmeContent -ne $updatedReadmeContent) {
                Set-Content -Path $readmeFile -Value $updatedReadmeContent -Encoding utf8
            } else {
                 Write-Warning "Failed to find and replace the installer name in README.md."
                 # Revert potential partial changes? Or just signal no changes?
                 $changesMade = "false"
                 # Optionally: Restore old installer if removed?
                 # Copy-Item -Path $newInstaller -Destination $oldInstaller # This assumes new wasn't identical
            }

            if ($changesMade -eq "true") {
              Write-Host "Staging changes..."
              git config --global user.name 'github-actions[bot]'
              git config --global user.email 'github-actions[bot]@users.noreply.github.com'
              git add $readmeFile
              git add $newInstaller # Add the new installer file
              # If the old file was properly removed, `git add .` might also work, but being specific is safer.
              # git add .

              Write-Host "Committing changes..."
              git commit -m "chore: Update MuMu installer to $newInstaller"
            }

          } else {
            Write-Host "Installer filename ($newInstaller) is the same as the old one ($oldInstaller) or old installer not found. No update needed."
            # Clean up the downloaded file if it wasn't needed and is different from old one
            if (($newInstaller -ne $oldInstaller) -and (Test-Path -Path $newInstaller)) {
               Write-Host "Removing duplicate downloaded file: $newInstaller"
               Remove-Item -Path $newInstaller -Force -ErrorAction SilentlyContinue
            }
            $changesMade = "false"
          }

          Write-Host "changes_made=$changesMade" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: Commit and push changes
        if: steps.update_script.outputs.changes_made == 'true'
        run: |
          git push origin HEAD:${{ github.ref_name }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Use the default token

      - name: No changes detected
        if: steps.update_script.outputs.changes_made == 'false'
        run: Write-Host "No new installer version detected or update failed." 